<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /* 
       let  声明的变量  
       
          只在它所在的块级作用域中有效

          不存在变量提升

          暂时性死区
          
          不允许重复声明
    
    */

      // for (let i = 0; i < 10; i++) {
      //   //...
      // }
      // console.log(i);   // i 没有定义

      // var a = []
      // for ( var i = 0; i < 10; i++) {
      //   a[i] = function () {
      //     console.log(i)
      //   }
      // }
      // a[6]  // 10

      // for ( let i = 0; i < 10; i++) {
      //   a[i] = function () {
      //     console.log(i)
      //   }
      // }
      // a[6]  // 6

      /* 
       解析: 变量i 是var 声明的， 在全局范围内都有效, 所以全局只有一个变量i, 
       每次循环全局的i都会发生改变, console 中的i指向全局的i。
       也就是说，所有数组a的成员里面的i， 都是指向同一个i， 导致运行时输出的最后一轮的i的值， 也就是10。


       如果使用let, 声明的变量仅在块级作用域内有效, 最后输出6
    */

      // var 声明的会发生变量提升
      //  console.log(foo);   // 会输出 undefined
      //  var foo = 2

      // //  let 声明的变量不会发生变量提升
      //  console.log(bar);   // 报错
      //  let bar = 3

      // 暂时性死区: 他所声明的变量就"绑定"了这个作用域， 不再受外部的影响

      // 本质 : 只要一进入当前作用域, 所要使用的变量就已经存在了, 但是不可获取, 只有等到声明变量的那一行代码出现, 才可以获取和使用该变量

      // var temp = 123;
      // if (true) {
      //   console.log(temp);
      //   let temp;
      // }

      /* 
       上面代码中， 存在全局变量 temp, 这时块级作用域内let 又声明了一个tmp

    */

      // typeof x  // 报错
      // let x

      // typeof undeclared_variable  // undefined

      // function bar (x = y, y = 2) {
      //   return [ x, y]
      // }
      // bar ()  // 报错 出现暂时性死区

      // function foo (x = 2, y = x) {
      //   return [x, y]
      // }
      // foo()   // [2,2 ]

      // var x = x   //  不会报错

      // 使用let声明时, 在let声明语句还没有执行完成就去取x的值, 导致报错  x 没有定义
      // let x = x   // x is not undefined

      // var tmp = new Date ()

      // function f () {
      //   console.log(tmp);

      //   if(false) {
      //     var temp = 'hello world'
      //   }
      // }

      // f()

      function f1() {
        var n = 5;
        if (true) {
          var n = 10;
        }
        console.log(n); // 5
      }
      f1()

      // 如果是let的话 那么 n 的值为5


      // const 声明一个常量  其具体规则和let差不多

      //  只有一个地方不同 const 要在声明的时候就赋值, 且一旦复制, 就不可更改

      //  const 实际保证的， 并不是变量的值不得改动, 而是变量指向的那个内存地址所保存的数据不得改动
      // 对于简单的数据类型， 值就保存在变量指向的那个内存地址, 因此等同于常量
      // 但是对于复杂的数据类型， 变量指向的内存地址， 保存的只是一个指向实际数据的指针, const只能保证这个指针不能发生变化, 
      // 至于他所指向的数据结构是不是可变的就完全不能控制了
    </script>
  </body>
</html>
